# 优化之线程

#### 线程调度模型

* 分时调度模型：　轮流获取，均分ＣＰＵ时间
* 抢占式调度模型：　优先级高的获取，ＪＶＭ采用

#### Android 线程调度

* nice值

    * Process中定义
    * 值越小,优先级越高
    * 默认是THREAD_PROPITY_DEFAULT , 0

* cgroup

    * 更严格的群组调度策略
    * 保证前台的线程可以获取得到更多的CPU

    


#### 注意点

* 线程过多会导致CPU 频繁切换, 降低线程的运行效率

* 正确认识任务的重要性决定那种优先级

* 线程的继承性(在线程A中创建了一个线程B, 则B 的**优先级**和A一样)

    

####  **Android 中的异步方式**

1. #### **Thread**

    * 最简单,最常见的异步方式' 
    * 不易复用, 频繁创建以及开销比较大
    * 复杂场景下不易使用

2. #### **HandlerThread**

    * 自带消息循环的线程
    * 串行执行
    * 长时间运行, 不断的从队列中获取任务(场景)

    

3. #### **IntentService**

    * 内部实现是通过一个HandlerThread
    * 异步, 不占用主线程
    * 优先级较高, 不易被系统kill

    

4. #### **AsyncTask**

    * Android 提供,内部实现是线程池 +  Handler
    * 无需自己处理线程切换
    * 版本的问题

    

5. #### **线程池**

    * Java 提供
    * 容易复用,减少频繁创建,销毁时间
    * 功能强大, 定时,任务队列, 并发数控制

    

6. ####  **Rxjava**

    * 强大的Scheduler 集合提供
    * 不同类型的区分: IO , Computation 的线程池

    

### 实战准则:

1. #### 严禁使用new **Thread**

2. #### 提供一个基础的线程池提供给各个业务线使用,避免每个业务各自维护一个线程池, 导致线程池过多

3. #### 需要任务的类型,来选择合适的异步方式

    * 低优先级，　长时间执行，　ＨａｎｄｌｅｒＴｈｒｅａｄ
    * 定时执行，　线程池

4. #### 创建线程必须命名

    * 方便定位线程归属
    * 运行期使用Thread.getThread().setName()

5. #### **关键异步任务监控**

    * 异步任务也耗时
    * AOP方式来监控

6. #### **重视优先级设置**

    * Process.setThreadPriopity();
    * 可以设置多次

### **实战**

创建一个公共的线程池工具





### **锁定线程的创建方案**

* 适合适合Ｈｏｏｋ　的手段





### 线程池的选择

* #### CPU　密集型

    如果并发数超过了核心数, 导致CPU频繁切换, 降低了平均效率, 所以核心池大小要和CPU核心数相关

* #### ＩＯ　密集型

    **特点：任务不消耗CPU , 核心线程池 可以很大**, 比如网络请求 io读写



面试

怎么对线程进行优化

1. 线程收敛

2. 统一线程池:任务区分

3. 其他细节

    * 通过Ｈｏｏｋ　监控线程执行时间

    * 设置线程名

　





















































